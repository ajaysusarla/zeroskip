#include <errno.h>
#include <getopt.h>
#include <inttypes.h>
#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>

#include <libzeroskip/cstring.h>
#include <libzeroskip/macros.h>
#include <libzeroskip/strarray.h>
#include <libzeroskip/util.h>
#include <libzeroskip/version.h>
#include <libzeroskip/zeroskip.h>

/* Globals */
static char *DBNAME;
static int NUMRECS = 1000;
static int new_db = 0;          /* set to 1 if we created a new db */
static size_t VALLEN = 0;

static char *create_tmp_dir_name(void)
{
       static const char charset[] =
                "abcdefghijklmnopqrstuvwxyz"
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                "0123456789";
        static const int num_chars = 62;
        uint64_t value;
        struct timeval tv;
        const char *tmpdir;
        char path[PATH_MAX];
        char *dirname_template;
        int i, ret = 1;
        struct stat sb;

        gettimeofday(&tv, NULL);
        value = ((size_t)(tv.tv_usec << 16)) ^ tv.tv_sec ^ getpid();

        tmpdir = getenv("TMPDIR");
        if (!tmpdir)
                tmpdir = "/tmp";

        snprintf(path, sizeof(path), "%s/zsbench-XXXXXX", tmpdir);

        dirname_template = &path[strlen(path) - 6];

        /* TMP_MAX: The minimum number of unique filenames generated by
         * tmpnam() */
        for (i = 0; i < TMP_MAX; ++i) {
                uint64_t v = value;
                int j;

                ret = 1;

                /* Fill in the random bits. */
                for (j = 0; j < 6; j++) {
                        dirname_template[j] = charset[v % num_chars];
                        v /= num_chars;
                }

                if (stat(path, &sb) == -1) {
                        if (errno == ENOENT) {
                                /* FOUND an unused path! */
                                ret = 0;
                                break;
                        }
                }

                value += 9999;
        }

        if (!ret)
                return xstrdup(path);
        else
                return NULL;
}

static char *generate_random_string(char *str, size_t length)
{
        static const char charset[] =
                "abcdefghijklmnopqrstuvwxyz"
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                "0123456789"
                "!@#$%^&*()-=_+|{}[];<>,./?:";

        if (length) {
                --length;

                for (size_t n = 0; n < length; n++) {
                        int pos = rand() % (int) (sizeof charset - 1);
                        str[n] = charset[pos];
                }

                str[length] = '\0';
        }

        return str;
}

static char *random_string(size_t length)
{
     char *s = xmalloc(length + 1);

     generate_random_string(s, length);

     return s;
}

static void cleanup_db_dir(void)
{
        recursive_rm(DBNAME);
}

static uint64_t get_time_now(void)
{
        struct timeval tv;
        gettimeofday(&tv, NULL);

        return tv.tv_sec * 1000000 + tv.tv_usec;
}

static void print_warnings(void)
{
}

static void print_environment(void)
{
        fprintf(stderr, "Zeroskip:       version %s\n", ZS_VERSION);

#if defined(LINUX)
        time_t now = time(NULL);
        fprintf(stderr, "Date:           %s", ctime(&now));;

        FILE *cpuinfo = fopen("/proc/cpuinfo", "r");
        if (cpuinfo != NULL) {
                char line[1000];
                int num_cpus = 0;
                cstring cpu_type;
                cstring cache_size;

                cstring_init(&cpu_type, 0);
                cstring_init(&cache_size, 0);

                while (fgets(line, sizeof(line), cpuinfo) != NULL) {
                        const char *sep = strchr(line, ':');
                        cstring key, val;

                        if (sep == NULL)
                                continue;

                        cstring_init(&key, 0);
                        cstring_init(&val, 0);

                        cstring_add(&key, line, (sep - 1 - line));
                        cstring_trim(&key);

                        cstring_addstr(&val, (sep + 1));
                        cstring_trim(&val);

                        if (strcmp("model name", key.buf) == 0) {
                                ++num_cpus;
                                cstring_release(&cpu_type);
                                cstring_addstr(&cpu_type, val.buf);
                        } else if (strcmp("cache size", key.buf) == 0) {
                                cstring_release(&cache_size);
                                cstring_addstr(&cache_size, val.buf);
                        }

                        cstring_release(&key);
                        cstring_release(&val);
                }

                fclose(cpuinfo);

                fprintf(stderr, "CPU:            %d * [%s]\n",
                        num_cpus, cpu_type.buf);
                fprintf(stderr, "CPUCache:       %s\n", cache_size.buf);

                cstring_release(&cpu_type);
                cstring_release(&cache_size);
        }
#endif
}

static void print_header(void)
{
        print_environment();
        print_warnings();
        fprintf(stdout, "------------------------------------------------\n");
}

/* static size_t do_write(int txnmode, int insmode) */
/* { */
/*         int i; */
/*         int ret; */
/*         struct zsdb *db = NULL; */
/*         size_t bytes = 0; */
/*         struct zsdb_txn *txn = NULL; */

/*         /\* Open Zeroskip DB *\/ */
/*         ret = zsdb_init(&db, NULL, NULL); */
/*         assert(ret == ZS_OK); */
/*         ret = zsdb_open(db, DBNAME, new_db ? MODE_CREATE : MODE_RDWR); */
/*         assert(ret == ZS_OK); */

/*         zsdb_write_lock_acquire(db, 0); */

/*         for (i = 0; i < NUMRECS; i++) { */
/*                 char key[100]; */
/*                 size_t keylen, vallen; */
/*                 char *val; */
/*                 int k; */

/*                 k = (insmode == SEQUENTIAL) ? i : ((time(NULL) *  i) % NUMRECS); */

/*                 snprintf(key, sizeof(key), "%016d", k); */
/*                 keylen = strlen(key); */
/*                 vallen = VALLEN ? VALLEN : keylen * 2; */
/*                 val = random_string(vallen); */

/*                 if (txnmode == BATCHED) { */
/*                         ret = zsdb_transaction_begin(db, &txn); */
/*                         assert(ret == ZS_OK); */
/*                 } */

/*                 ret = zsdb_add(db, (unsigned char *)key, keylen, */
/*                                (unsigned char *)val, vallen, &txn); */

/*                 assert(ret == ZS_OK); */
/*                 bytes += (keylen + vallen); */

/*                 if (txnmode == BATCHED) { */
/*                         ret = zsdb_commit(db, &txn); */
/*                         assert(ret == ZS_OK); */
/*                 } */
/*         } */

/*         zsdb_write_lock_release(db); */

/*         if (txnmode == NOTBATCHED) */
/*                 zsdb_commit(db, NULL); */

/*         /\* Close Zeroskip DB *\/ */
/*         ret = zsdb_close(db); */
/*         assert(ret == ZS_OK); */
/*         zsdb_final(&db); */


/*         return bytes; */
/* } */

static int run_many(void)
{
        uint64_t start, finish;
        size_t bytes;

        print_header();

        return 0;
}


int main(int argc, char **argv)
{
        int ret = EXIT_SUCCESS;
        int seed = 1103515245;

        new_db = 1;
        DBNAME = create_tmp_dir_name();
        assert(DBNAME != NULL);
        printf("Creating a new DB: %s\n", DBNAME);

        ret = run_many();

        cleanup_db_dir();
        free(DBNAME);

        exit(ret);
}
