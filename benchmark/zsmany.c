#include <errno.h>
#include <getopt.h>
#include <inttypes.h>
#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>

#include <libzeroskip/cstring.h>
#include <libzeroskip/macros.h>
#include <libzeroskip/strarray.h>
#include <libzeroskip/util.h>
#include <libzeroskip/version.h>
#include <libzeroskip/zeroskip.h>

/* Globals */
static char *DBNAME;
static int NUMRECS = 1000;
static int new_db = 0;          /* set to 1 if we created a new db */
static size_t VALLEN = 0;

static char *create_tmp_dir_name(void)
{
       static const char charset[] =
                "abcdefghijklmnopqrstuvwxyz"
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                "0123456789";
        static const int num_chars = 62;
        uint64_t value;
        struct timeval tv;
        const char *tmpdir;
        char path[PATH_MAX];
        char *dirname_template;
        int i, ret = 1;
        struct stat sb;

        gettimeofday(&tv, NULL);
        value = ((size_t)(tv.tv_usec << 16)) ^ tv.tv_sec ^ getpid();

        tmpdir = getenv("TMPDIR");
        if (!tmpdir)
                tmpdir = "/tmp";

        snprintf(path, sizeof(path), "%s/zsbench-XXXXXX", tmpdir);

        dirname_template = &path[strlen(path) - 6];

        /* TMP_MAX: The minimum number of unique filenames generated by
         * tmpnam() */
        for (i = 0; i < TMP_MAX; ++i) {
                uint64_t v = value;
                int j;

                ret = 1;

                /* Fill in the random bits. */
                for (j = 0; j < 6; j++) {
                        dirname_template[j] = charset[v % num_chars];
                        v /= num_chars;
                }

                if (stat(path, &sb) == -1) {
                        if (errno == ENOENT) {
                                /* FOUND an unused path! */
                                ret = 0;
                                break;
                        }
                }

                value += 9999;
        }

        if (!ret)
                return xstrdup(path);
        else
                return NULL;
}


static void cleanup_db_dir(void)
{
        printf("Cleaning up DB: %s\n", DBNAME);
        recursive_rm(DBNAME);
}

static uint64_t get_time_now(void)
{
        struct timeval tv;
        gettimeofday(&tv, NULL);

        return tv.tv_sec * 1000000 + tv.tv_usec;
}

static const char *nth_compound(unsigned int n,
                                const char * const * words /*[37]*/,
                                const char *sep,
                                cstring *res)
{
        size_t len = 0;
        cstring_init(res, 0);

        if ((n / 1000) % 10) {
                cstring_addstr(res, words[28 + (n / 1000) % 10]);
        }

        if ((n / 100) % 10) {
                if (res->len && sep)
                        cstring_addstr(res, sep);
                cstring_addstr(res, words[19 + (n / 100) % 10]);
        }

        if ((n / 10) % 10) {
                if (res->len && sep)
                        cstring_addstr(res, sep);
                cstring_addstr(res, words[10 + (n / 10) % 10]);
        }

        if (res->len && sep)
                cstring_addstr(res, sep);
        cstring_addstr(res, words[n % 10]);

        return cstring_detach(res, &len);
}

static const char *nth_key(unsigned int n)
{
        static const char * const words[37] = {
                "dray", "bite", "cue", "ado", "felt",
                "firm", "sal", "ahab", "cab", "lord",
                "blob", "be", "coil", "hay",
                "bled", "got", "leta", "sept", "deft",
                "ibm", "kama", "bean", "ado",
                "cord", "firm", "ben", "fore", "huck",
                "haas", "jack", "aden", "nerf",
                "gash", "stu", "nona", "gel", "ale"
        };
        static cstring buf;
        return nth_compound(n, words, ".", &buf);
}

static const char *nth_data(unsigned int n)
{
        static const char * const words[37] = {
                "abettor", "afresh", "aisling", "arthur", "ascots",
                "belled", "berserk", "border", "bourbon", "brawny",
                "carpels", "cavils", "coating", "cologne",
                "concern", "consul", "crater", "crocks", "deirdre",
                "dewier", "disdain", "dowdier", "duncan",
                "eighth", "enigma", "evelyn", "fennel", "flowery",
                "flukier", "forums", "gametes", "gamins",
                "gavels", "gibbers", "gulags", "gunther", "gunwale"
        };
        static cstring buf;
        return nth_compound(n, words, " ", &buf);
}

static void print_warnings(void)
{
}

static void print_environment(void)
{
        fprintf(stderr, "Zeroskip:       version %s\n", ZS_VERSION);

#if defined(LINUX)
        time_t now = time(NULL);
        fprintf(stderr, "Date:           %s", ctime(&now));;

        FILE *cpuinfo = fopen("/proc/cpuinfo", "r");
        if (cpuinfo != NULL) {
                char line[1000];
                int num_cpus = 0;
                cstring cpu_type;
                cstring cache_size;

                cstring_init(&cpu_type, 0);
                cstring_init(&cache_size, 0);

                while (fgets(line, sizeof(line), cpuinfo) != NULL) {
                        const char *sep = strchr(line, ':');
                        cstring key, val;

                        if (sep == NULL)
                                continue;

                        cstring_init(&key, 0);
                        cstring_init(&val, 0);

                        cstring_add(&key, line, (sep - 1 - line));
                        cstring_trim(&key);

                        cstring_addstr(&val, (sep + 1));
                        cstring_trim(&val);

                        if (strcmp("model name", key.buf) == 0) {
                                ++num_cpus;
                                cstring_release(&cpu_type);
                                cstring_addstr(&cpu_type, val.buf);
                        } else if (strcmp("cache size", key.buf) == 0) {
                                cstring_release(&cache_size);
                                cstring_addstr(&cache_size, val.buf);
                        }

                        cstring_release(&key);
                        cstring_release(&val);
                }

                fclose(cpuinfo);

                fprintf(stderr, "CPU:            %d * [%s]\n",
                        num_cpus, cpu_type.buf);
                fprintf(stderr, "CPUCache:       %s\n", cache_size.buf);

                cstring_release(&cpu_type);
                cstring_release(&cache_size);
        }
#endif
}

static void print_header(void)
{
        print_environment();
        print_warnings();
        fprintf(stdout, "------------------------------------------------\n");
}

static int run_many(void)
{
        uint64_t start, finish;
        int i;
        int ret;
        struct zsdb *db = NULL;
        size_t bytes = 0;
        struct zsdb_txn *txn = NULL;
        unsigned int MAXN = 4095;
        unsigned int n;

        print_header();

        /* Open Zeroskip DB */
        ret = zsdb_init(&db, NULL, NULL);
        assert(ret == ZS_OK);
        ret = zsdb_open(db, DBNAME, new_db ? MODE_CREATE : MODE_RDWR);
        assert(ret == ZS_OK);

        zsdb_write_lock_acquire(db, 0);

        /* Store some records */
        for (n = 0; n <= MAXN; n++) {
                const char *key = nth_key(n);
                const char *data = nth_data(n);
                size_t keylen, datalen;
                keylen = strlen(key);
                datalen = strlen(data);
                ret = zsdb_add(db, (unsigned char *)key, keylen,
                               (unsigned char *)data, datalen, &txn);
                assert(ret == ZS_OK);
                bytes += keylen + datalen;
        }

        zsdb_write_lock_release(db);

        /* Commit succeeds */
        zsdb_commit(db, &txn);
        assert(ret == ZS_OK);

        /* check the records all made it */
        for (n = 0; n <= MAXN; n++) {
                const char *key = nth_key(n);
                const char *expdata = nth_data(n);
                const char *data;
                size_t keylen, expdatalen, datalen;
                keylen = strlen(key);
                expdatalen = strlen(expdata);

                ret = zsdb_fetch(db, (const unsigned char *)key,
                                 keylen,
                                 &data, &datalen, &txn);
                assert(ret == ZS_OK);
                assert(expdatalen == datalen);
                assert(!memcmp(data, expdata, datalen));
        }

        /* Close Zeroskip DB */
        ret = zsdb_close(db);
        assert(ret == ZS_OK);
        zsdb_final(&db);

        return bytes;
}


int main(int argc, char **argv)
{
        int ret = EXIT_SUCCESS;
        int seed = 1103515245;

        new_db = 1;
        DBNAME = create_tmp_dir_name();
        assert(DBNAME != NULL);
        printf("Creating a new DB: %s\n", DBNAME);

        ret = run_many();

        cleanup_db_dir();
        free(DBNAME);

        exit(ret);
}
